# 비교 연산자

우리는 수학 시간에 아래와 같은 다양한 비교 연산자에 대해 학습한 바 있습니다.

자바스크립트에서 기본 수학 연산은 아래와 같은 문법을 사용해 표현할 수 있습니다.

- 보다 큼·작음: <code>a &gt; b</code>, <code>a &lt; b</code>
- 보다 크거나·작거나 같음: <code>a &gt;= b</code>, <code>a &lt;= b</code>
- 같음(동등): `a == b`. 등호 `=`가 두 개 연달아 오는 것에 유의하세요. `a ​​= b`와 같이 등호가 하나일 때는 할당을 의미합니다.
- 같지 않음(부등): 같지 않음을 나타내는 수학 기호 <code>&ne;</code>는 자바스크립트에선 <code>a != b</code>로 나타냅니다. 할당연산자 `=` 앞에 느낌표 `!`를 붙여서 표시합니다.

이번 글에선 비교 시 일어나는 기이한 현상을 포함하여 다양한 자료형을 대상으로 자바스크립트가 어떻게 비교를 하는지에 대해 다룰 예정입니다.

글 말미에는 자바스크립트에서만 일어나는 '기이한' 현상을 어떻게 예방할 수 있는지에 대해서 언급해두었습니다.

## 불린형 반환

다른 연산자와 마찬가지로 비교 연산자 역시 값을 반환합니다. 반환 값은 불린형입니다.

- `true`가 반환되면, '긍정', '참', '사실'을 의미합니다.
- `false`가 반환되면, '부정', '거짓', '사실이 아님'을 의미합니다.

예시:

```js run
alert(2 > 1); // true
alert(2 == 1); // false
alert(2 != 1); // true
```

반환된 불린값은 다른 여타 값처럼 변수에 할당 할 수 있습니다.

```js run
let result = 5 > 4; // 비교 결과를 변수에 할당
alert(result); // true
```

## 문자열 비교

자바스크립트는 '사전' 순으로 문자열을 비교합니다. '사전편집(lexicographical)'순이라고 불리기도 하는 이 기준을 적용하면 사전 뒤쪽의 문자열은 사전 앞쪽의 문자열보다 크다고 판단됩니다.

- a-z
- ㄱ-ㄴ
- 문자열의 길이
- 소문자 > 대문자

실제 단어를 사전에 실을 때 단어를 구성하는 문자 하나하나를 비교하여 등재 순서를 정하는 것과 같이 자바스크립트도 문자열을 구성하는 문자 하나하나를 비교해가며 문자열을 비교합니다.

예시:

```js run
alert("Z" > "A"); // true
alert("Glow" > "Glee"); // true
alert("Bee" > "Be"); // true
```

문자열 비교 시 적용되는 알고리즘은 다음과 같습니다.

1. 두 문자열의 첫 글자를 비교합니다.
2. 첫 번째 문자열의 첫 글자가 다른 문자열의 첫 글자보다 크면(작으면), 첫 번째 문자열이 두 번째 문자열보다 크다고(작다고) 결론 내고 비교를 종료합니다.
3. 두 문자열의 첫 글자가 같으면 두 번째 글자를 같은 방식으로 비교합니다.
4. 글자 간 비교가 끝날 때까지 이 과정을 반복합니다.
5. 비교가 종료되었고 문자열의 길이도 같다면 두 문자열은 동일하다고 결론 냅니다. 비교가 종료되었지만 두 문자열의 길이가 다르면 길이가 긴 문자열이 더 크다고 결론 냅니다.

예시의 `'Z' > 'A'`는 위 알고리즘의 첫 번째 단계에서 비교 결과가 도출됩니다. 반면, 문자열 `'Glow'`와 `'Glee'`는 복수의 문자로 이루어진 문자열이기 때문에, 아래와 같은 순서로 문자열 비교가 이뤄집니다.

1. `G`는 `G`와 같습니다.
2. `l`은 `l`과 같습니다.
3. `o`는 `e`보다 크기 때문에 여기서 비교가 종료되고, `o`가 있는 첫 번째 문자열 `'Glow'`가 더 크다는 결론이 도출됩니다.

```smart header="정확히는 사전 순이 아니라 유니코드 순입니다."
자바스크립트의 문자열 비교 알고리즘은 사전이나 전화번호부에서 사용되는 정렬 알고리즘과 아주 유사하지만, 완전히 같진 않습니다.

차이점 중 하나는 자바스크립트는 대·소문자를 따진다는 것입니다. 대문자 `'A'`와 소문자 `'a'`를 비교했을 때 소문자 `'a'`가 더 큽니다. 자바스크립트 내부에서 사용되는 인코딩 표인 유니코드에선 소문자가 대문자보다 더 큰 인덱스를 갖기 때문이죠.
```

## 다른 형을 가진 값 간의 비교

비교하려는 값의 자료형이 다르면 자바스크립트는 이 값들을 숫자형으로 바꿉니다.
즉, 비교형에 맞는 타입으로 변환시킨후 계산한다.

예시:

```js run
alert("2" > 1); // true, 문자열 '2'가 숫자 2로 변환된 후 비교가 진행됩니다.
alert("01" == 1); // true, 문자열 '01'이 숫자 1로 변환된 후 비교가 진행됩니다.
```

불린값의 경우 `true`는 `1`, `false`는 `0`으로 변환된 후 비교가 이뤄집니다.

예시:

```js run
alert(true == 1); // true
alert(false == 0); // true
```

## 일치 연산자

동등 연산자(equality operator) `==`은 `0`과 `false`를 구별하지 못합니다.

```js run
alert(0 == false); // true
```

피연산자가 빈 문자열일 때도 같은 문제가 발생하죠.

```js run
alert("" == false); // true
```

이런 문제는 동등 연산자 `==`가 형이 다른 피연산자를 비교할 때 피연산자를 숫자형으로 바꾸기 때문에 발생합니다. 빈 문자열과 `false`는 숫자형으로 변환하면 0이 되죠.

그렇다면 `0`과 `false`는 어떻게 구별할 수 있을까요?

**일치 연산자(strict equality operator) `===`를 사용하면 형 변환 없이 값을 비교할 수 있습니다.**

일치 연산자는 엄격한(strict) 동등 연산자입니다. 자료형의 동등 여부까지 검사하기 때문에 피연산자 `a`와 `b`의 형이 다를 경우 `a === b`는 즉시 `false`를 반환합니다.

일치 연산자는 등호를 사용해도 타입의 변화를 시키지 않고 타입까지 엄격하게 비교를 한다.

예시:

```js run
alert(0 === false); // false, 피연산자의 형이 다르기 때문입니다.
```

일치 연산자 `===`가 동등 연산자 `==`의 엄격한 버전인 것처럼 '불일치' 연산자 `!==`는 부등 연산자 `!=`의 엄격한 버전입니다.

일치 연산자는 동등 연산자보다 한 글자 더 길긴 하지만 비교 결과가 명확하기 때문에 에러가 발생할 확률을 줄여줍니다.

## null이나 undefined와 비교하기

`null`이나 `undefined`를 다른 값과 비교할 땐 예상치 않은 일들이 발생합니다. 일단 몇 가지 규칙을 먼저 살펴본 후, 어떤 예상치 않은 일들이 일어나는지 구체적인 예시를 통해 살펴보도록 하겠습니다.

일치 연산자 `===`를 사용하여 `null`과 `undefined`를 비교
: 두 값의 자료형이 다르기 때문에 일치 비교 시 거짓이 반환됩니다.

    ```js run
    alert( null === undefined ); // false
    ```

동등 연산자 `==`를 사용하여 `null`과 `undefined`를 비교
: 동등 연산자를 사용해 `null`과 `undefined`를 비교하면 특별한 규칙이 적용돼 `true`가 반환됩니다. 동등 연산자는 `null`과 `undefined`를 '각별한 커플'처럼 취급합니다. 두 값은 자기들끼리는 잘 어울리지만 다른 값들과는 잘 어울리지 못합니다.

    ```js run
    alert( null == undefined ); // true
    ```

산술 연산자나 기타 비교 연산자 `<`, `>`, `<=`, `>=`를 사용하여 `null`과 `undefined`를 비교
: `null`과 `undefined`는 숫자형으로 변환됩니다. `null`은 `0`, `undefined`는 `NaN`으로 변합니다.

## 요약

- 비교 연산자는 불린값을 반환합니다.
- 문자열은 문자 단위로 비교되는데, 이때 비교 기준은 '사전' 순입니다.
- 서로 다른 타입의 값을 비교할 땐 숫자형으로 형 변환이 이뤄지고 난 후 비교가 진행됩니다(일치 연산자는 제외).
- `null`과 `undefined`는 동등 비교(`==`) 시 서로 같지만 다른 값과는 같지 않습니다.
